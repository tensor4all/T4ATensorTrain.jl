var documenterSearchIndex = {"docs":
[{"location":"#T4ATensorTrain.jl","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.jl","text":"Tensor Train core functionality for tensor4all.","category":"section"},{"location":"#API","page":"T4ATensorTrain.jl","title":"API","text":"","category":"section"},{"location":"#T4ATensorTrain.AbstractTensorTrain","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.AbstractTensorTrain","text":"abstract type AbstractTensorTrain{V} <: Function end\n\nAbstract type that is a supertype to all tensor train types found in this module. The main purpose of this type is for the definition of functions such as rank and linkdims that are shared between different tensor train classes.\n\nWhen iterated over, the tensor train will return each of the tensors in order.\n\nImplementations: TensorTrain\n\n\n\n\n\n","category":"type"},{"location":"#T4ATensorTrain.Algorithm","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.Algorithm","text":"struct Algorithm{Name} end\n\nA type for dispatching on algorithm names. Used for the algorithm keyword in functions like contract.\n\nExample\n\ncontract(A, B; algorithm=:naive)  # Dispatches to contract(Algorithm\"naive\"(), A, B; ...)\n\n\n\n\n\n","category":"type"},{"location":"#T4ATensorTrain.TTCache","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.TTCache","text":"struct TTCache{ValueType}\n\nCached evalulation of a tensor train. This is useful when the same TT is evaluated multiple times with the same indices. The number of site indices per tensor core can be arbitray irrespective of the number of site indices of the original tensor train.\n\n\n\n\n\n","category":"type"},{"location":"#T4ATensorTrain.TensorTrain","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.TensorTrain","text":"struct TensorTrain{ValueType}\n\nRepresents a tensor train, also known as MPS.\n\nThe tensor train can be evaluated using standard function call notation:\n\n    tt = TensorTrain(...)\n    value = tt([1, 2, 3, 4])\n\nThe corresponding function is:\n\nfunction (tt::TensorTrain{V})(indexset) where {V}\n\nEvaluates the tensor train tt at indices given by indexset.\n\n\n\n\n\n","category":"type"},{"location":"#T4ATensorTrain.TensorTrain-Union{Tuple{AbstractTensorTrain{V}}, Tuple{V}} where V","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.TensorTrain","text":"function TensorTrain(tci::AbstractTensorTrain{V}) where {V}\n\nConvert a tensor-train-like object into a tensor train.\n\nSee also: TensorCI1 and TensorCI2 in T4ATensorCI.jl.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.TensorTrain-Union{Tuple{AbstractVector{<:AbstractArray{V, N}}}, Tuple{N}, Tuple{V}} where {V, N}","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.TensorTrain","text":"function TensorTrain(sitetensors::Vector{Array{V, 3}}) where {V}\n\nCreate a tensor train out of a vector of tensors. Each tensor should have links to the previous and next tensor as dimension 1 and 3, respectively; the local index (\"physical index\" for MPS in physics) is dimension 2.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.TensorTrain-Union{Tuple{N}, Tuple{V2}, Tuple{V}, Tuple{AbstractTensorTrain{V}, Any}} where {V, V2, N}","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.TensorTrain","text":"function TensorTrain{V2,N}(tci::AbstractTensorTrain{V}) where {V,V2,N}\n\nConvert a tensor-train-like object into a tensor train.\n\nArguments:\n\ntt::AbstractTensorTrain{V}: a tensor-train-like object.\nlocaldims: a vector of local dimensions for each tensor in the tensor train. A each element of localdims should be an array-like object of N-2 integers.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.TensorTrainFit","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.TensorTrainFit","text":"Fitting data with a TensorTrain object. This may be useful when the interpolated function is noisy.\n\n\n\n\n\n","category":"type"},{"location":"#Base.:+-Union{Tuple{V}, Tuple{AbstractTensorTrain{V}, AbstractTensorTrain{V}}} where V","page":"T4ATensorTrain.jl","title":"Base.:+","text":"function (+)(lhs::AbstractTensorTrain{V}, rhs::AbstractTensorTrain{V}) where {V}\n\nAddition of two tensor trains. If c = a + b, then c(v) ≈ a(v) + b(v) at each index set v. Note that this function increases the bond dimension, i.e. chi_textresult = chi_1 + chi_2 if the original tensor trains had bond dimensions chi_1 and chi_2. Can be combined with automatic recompression by calling add.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Union{Tuple{V}, Tuple{AbstractTensorTrain{V}, AbstractTensorTrain{V}}} where V","page":"T4ATensorTrain.jl","title":"Base.:-","text":"function (-)(lhs::AbstractTensorTrain{V}, rhs::AbstractTensorTrain{V}) where {V}\n\nSubtraction of two tensor trains. If c = a - b, then c(v) ≈ a(v) - b(v) at each index set v. Note that this function increases the bond dimension, i.e. chi_textresult = chi_1 + chi_2 if the original tensor trains had bond dimensions chi_1 and chi_2. Can be combined with automatic recompression by calling subtract (see documentation for add).\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Union{Tuple{AbstractTensorTrain{V}}, Tuple{V}} where V","page":"T4ATensorTrain.jl","title":"Base.length","text":"function length(tt::AbstractTensorTrain{V}) where {V}\n\nLength of the tensor train, i.e. the number of tensors in the tensor train.\n\n\n\n\n\n","category":"method"},{"location":"#Base.sum-Union{Tuple{AbstractTensorTrain{V}}, Tuple{V}} where V","page":"T4ATensorTrain.jl","title":"Base.sum","text":"function sum(tt::TensorTrain{V}) where {V}\n\nEvaluates the sum of the tensor train approximation over all lattice sites in an efficient factorized manner.\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.norm-Union{Tuple{AbstractTensorTrain{V}}, Tuple{V}} where V","page":"T4ATensorTrain.jl","title":"LinearAlgebra.norm","text":"Frobenius norm of a tensor train.\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.norm2-Union{Tuple{AbstractTensorTrain{V}}, Tuple{V}} where V","page":"T4ATensorTrain.jl","title":"LinearAlgebra.norm2","text":"Squared Frobenius norm of a tensor train.\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.rank-Union{Tuple{AbstractTensorTrain{V}}, Tuple{V}} where V","page":"T4ATensorTrain.jl","title":"LinearAlgebra.rank","text":"function rank(tt::AbstractTensorTrain{V}) where {V}\n\nRank of the tensor train, i.e. the maximum link dimension.\n\nSee also: linkdims, linkdim\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.add-Union{Tuple{V}, Tuple{AbstractTensorTrain{V}, AbstractTensorTrain{V}}} where V","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.add","text":"function add(\n    lhs::AbstractTensorTrain{V}, rhs::AbstractTensorTrain{V};\n    factorlhs=one(V), factorrhs=one(V),\n    tolerance::Float64=0.0, maxbonddim::Int=typemax(Int)\n) where {V}\n\nAddition of two tensor trains. If C = add(A, B), then C(v) ≈ A(v) + B(v) at each index set v. Note that this function increases the bond dimension, i.e. chi_textresult = chi_1 + chi_2 if the original tensor trains had bond dimensions chi_1 and chi_2.\n\nArguments:\n\nlhs, rhs: Tensor trains to be added.\nfactorlhs, factorrhs: Factors to multiply each tensor train by before addition.\ntolerance, maxbonddim: Parameters to be used for the recompression step.\n\nReturns: A new TensorTrain representing the function factorlhs * lhs(v) + factorrhs * rhs(v).\n\nSee also: +\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.batchevaluate-Union{Tuple{M}, Tuple{V}, Tuple{TTCache{V}, AbstractVector{Vector{Int64}}, AbstractVector{Vector{Int64}}, Val{M}}, Tuple{TTCache{V}, AbstractVector{Vector{Int64}}, AbstractVector{Vector{Int64}}, Val{M}, Union{Nothing, AbstractVector{<:AbstractVector{<:Integer}}}}} where {V, M}","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.batchevaluate","text":"projector: 0 means no projection, otherwise the index of the projector\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.compress!-Union{Tuple{TensorTrain{V, N}}, Tuple{N}, Tuple{V}, Tuple{TensorTrain{V, N}, Symbol}} where {V, N}","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.compress!","text":"function compress!(\n    tt::TensorTrain{V, N},\n    method::Symbol=:LU;\n    tolerance::Float64=1e-12,\n    maxbonddim=typemax(Int)\n) where {V, N}\n\nCompress the tensor train tt using LU, CI or SVD decompositions.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.contract-Union{Tuple{V2}, Tuple{V1}, Tuple{TensorTrain{V1, 4}, TensorTrain{V2, 4}}} where {V1, V2}","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.contract","text":"function contract(\n    A::TensorTrain{V1,4},\n    B::TensorTrain{V2,4};\n    algorithm::Symbol=:naive,\n    tolerance::Float64=1e-12,\n    maxbonddim::Int=typemax(Int),\n    kwargs...\n) where {V1,V2}\n\nContract two tensor trains A and B.\n\nAvailable implementations:\n\nalgorithm=:naive uses a naive tensor contraction and subsequent SVD recompression of the tensor train.\nalgorithm=:zipup uses a naive tensor contraction with on-the-fly LU decomposition.\n\nFor TCI-based contraction (algorithm=:TCI), use T4ATensorCI.jl which extends this function.\n\nArguments:\n\nA and B are the tensor trains to be contracted.\nalgorithm chooses the algorithm used to evaluate the contraction.\ntolerance is the tolerance of the SVD recompression.\nmaxbonddim sets the maximum bond dimension of the resulting tensor train.\nmethod chooses the method used for the factorization in the algorithm=:zipup case (:SVD or :LU).\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.contract_zipup-Union{Tuple{ValueType}, Tuple{TensorTrain{ValueType, 4}, TensorTrain{ValueType, 4}}} where ValueType","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.contract_zipup","text":"See SVD version: https://tensornetwork.org/mps/algorithms/zipupmpo/\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.evaluate-Union{Tuple{V}, Tuple{AbstractTensorTrain{V}, CartesianIndex}} where V","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.evaluate","text":"function evaluate(tt::TensorTrain{V}, indexset::CartesianIndex) where {V}\n\nEvaluates the tensor train tt at indices given by indexset.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.evaluate-Union{Tuple{V}, Tuple{AbstractTensorTrain{V}, Union{NTuple{N, Int64} where N, AbstractVector{Int64}}}} where V","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.evaluate","text":"function evaluate(\n    tt::TensorTrain{V},\n    indexset::Union{AbstractVector{LocalIndex}, NTuple{N, LocalIndex} where N}\n) where {V}\n\nEvaluates the tensor train tt at indices given by indexset.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.isleftorthogonal-Union{Tuple{AbstractArray{ValueType, N}}, Tuple{N}, Tuple{ValueType}} where {ValueType, N}","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.isleftorthogonal","text":"function isleftorthogonal(T::AbstractArray{ValueType,N}; atol::Float64=1e-7)::Bool where {ValueType, N}\n\nCheck if a tensor is left-orthogonal, i.e., contracting the first N-1 dimensions with their conjugates gives the identity.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.isrightorthogonal-Union{Tuple{AbstractArray{ValueType, N}}, Tuple{N}, Tuple{ValueType}} where {ValueType, N}","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.isrightorthogonal","text":"function isrightorthogonal(T::AbstractArray{ValueType,N}; atol::Float64=1e-7)::Bool where {ValueType, N}\n\nCheck if a tensor is right-orthogonal, i.e., contracting the last N-1 dimensions with their conjugates gives the identity.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.linkdim-Union{Tuple{V}, Tuple{AbstractTensorTrain{V}, Int64}} where V","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.linkdim","text":"function linkdim(tt::AbstractTensorTrain{V}, i::Int)::Int where {V}\n\nBond dimensions at the link between tensor T_i and T_i+1 in the tensor train.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.linkdims-Union{Tuple{AbstractTensorTrain{V}}, Tuple{V}} where V","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.linkdims","text":"function linkdims(tt::AbstractTensorTrain{V})::Vector{Int} where {V}\n\nBond dimensions along the links between T tensors in the tensor train. Returns the bond dimensions along the links between neighboring tensors.\n\nSee also: rank\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.projector_to_slice-Tuple{AbstractVector{<:Integer}}","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.projector_to_slice","text":"Construct slice for the site indices of one tensor core Returns a slice and the corresponding shape for resize\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.reshapephysicalleft-Union{Tuple{AbstractArray{ValueType, N}}, Tuple{N}, Tuple{ValueType}} where {ValueType, N}","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.reshapephysicalleft","text":"function reshapephysicalleft(T::AbstractArray{ValueType, N}) where {ValueType, N}\n\nReshape tensor to matrix with all dimensions except last as rows and last dimension as columns.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.reshapephysicalright-Union{Tuple{AbstractArray{ValueType, N}}, Tuple{N}, Tuple{ValueType}} where {ValueType, N}","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.reshapephysicalright","text":"function reshapephysicalright(T::AbstractArray{ValueType, N}) where {ValueType, N}\n\nReshape tensor to matrix with first dimension as rows and all other dimensions as columns.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.sitedim-Union{Tuple{V}, Tuple{AbstractTensorTrain{V}, Int64}} where V","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.sitedim","text":"function linkdim(tt::AbstractTensorTrain{V}, i::Int)::Int where {V}\n\nDimension of the ith site index along the tensor train.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.sitedims-Union{Tuple{AbstractTensorTrain{V}}, Tuple{V}} where V","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.sitedims","text":"function sitedims(tt::AbstractTensorTrain{V})::Vector{Vector{Int}} where {V}\n\nDimensions of the site indices (local indices, physical indices) of the tensor train.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.sitetensor-Union{Tuple{V}, Tuple{AbstractTensorTrain{V}, Any}} where V","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.sitetensor","text":"sitetensors(tt::AbstractTensorTrain{V}, i) where {V}\n\nThe tensor at site i of the tensor train.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.sitetensors-Union{Tuple{AbstractTensorTrain{V}}, Tuple{V}} where V","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.sitetensors","text":"sitetensors(tt::AbstractTensorTrain{V}) where {V}\n\nThe tensors that make up the tensor train.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.subtract-Union{Tuple{V}, Tuple{AbstractTensorTrain{V}, AbstractTensorTrain{V}}} where V","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.subtract","text":"function subtract(\n    lhs::AbstractTensorTrain{V}, rhs::AbstractTensorTrain{V};\n    tolerance::Float64=0.0, maxbonddim::Int=typemax(Int)\n)\n\nSubtract two tensor trains lhs and rhs. See add.\n\n\n\n\n\n","category":"method"},{"location":"#T4ATensorTrain.@Algorithm_str-Tuple{Any}","page":"T4ATensorTrain.jl","title":"T4ATensorTrain.@Algorithm_str","text":"@Algorithm_str(s)\n\nA string macro for creating Algorithm types.\n\nExample\n\nAlgorithm\"naive\"  # Same as Algorithm{:naive}\n\n\n\n\n\n","category":"macro"}]
}
